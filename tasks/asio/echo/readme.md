# Эхо-сервер

*Programs must be written for people to read, and only incidentally for machines to execute.* – Harold Abelson, Gerald Jay Sussman

---

Эхо-сервер – это _HelloWorld_ мира сетевых приложений. Его задача – принимать
TCP-соединения клиентов, читать из них данные и отправлять их обратно. Поэтому и _эхо_.

Написать эхо-сервер можно по-разному...

## Потоки и синхронность

Посмотрим на простую [многопоточную реализацию](https://github.com/chriskohlhoff/asio/blob/master/asio/src/examples/cpp11/echo/blocking_tcp_echo_server.cpp) с использованием библиотеки [Asio](https://github.com/chriskohlhoff/asio/).

В этой реализации на каждого клиента заводится отдельный поток, который в цикле читает из клиентского сокета очередную порцию данных и затем пишет ее обратно в сокет.

Чтение из сокета и запись в сокет в этом коде выполняются _синхронно_:
- Вызов `read_some` не вернет управление до тех пор, пока в сокете не появятся данные.
- Аналогично, вызов `write` не завершится, если клиент на другой стороне соединения долго не вычитывает данные.

Это _синхронное_ API.

## Асинхронность и коллбэки
Можно написать тот же эхо-сервер совсем иначе, с использованием _асинхронного_ API, и обойтись всего одним потоком:

[Асинхронная реализация эхо-сервера](echo/server.cpp)

- При вызове `async_read_some` на сокете мы не блокируемся до момента появления данных, а _подписываемся_ на результат чтения – передаем в вызов _коллбэк_ (_callback_), который будет вызван после завершения чтения, после чего вызов `async_read_some` завершается _без ожидания_.
- Аналогично с записью в сокет через `async_write`.

## Задача

К сожалению, приведенная выше асинхронная реализация не дописана и не проходит тесты. Ваша задача – довести её до рабочего состояния.

## Вопросы на понимание

- Где в этом коде спрятан [epoll](http://man7.org/linux/man-pages/man7/epoll.7.html)?

- Как организовано управление памятью? Зачем коллбэк, который передается в `async_read_some`, захватывает одновременно и `this`, и `self` – умный указатель на текущий `Session`, полученный из `shared_from_this()`?

- Как из произвольного синхронного кода получить эквивалентный асинхронный?

## Мораль

Мораль этой задачи, конечно, не в том, чтобы научиться писать эхо-сервер или изучить библиотеку _Asio_, хотя и то и другое полезно само по себе.

Эта задача должна побудить вас на размышления над тем, насколько по-разному выглядит синхронный код с потоками и асинхронный код на коллбэках, как по-разному организован в этих подходах поток управления.

Какой код легче читать и писать? Какая из реализаций эффективнее? Можно ли совместить сильные стороны обоих подходов?

## Материалы

* [Asio](https://github.com/chriskohlhoff/asio/)
* [Basic Asio Anatomy](http://think-async.com/Asio/asio-1.18.1/doc/asio/overview/core/basics.html)
* [Thinking Asynchronously: Designing Applications with Boost.Asio](https://www.youtube.com/watch?v=D-lTwGJRx0o), [слайды](http://cpp.mimuw.edu.pl/files/boost_vs_qt/asio/thinking_asynchronously.pdf)
