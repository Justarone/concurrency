# Мьютекс

В этой задаче вы должны реализовать [std::mutex](https://ru.cppreference.com/w/cpp/thread/mutex). 

Отличие мьютекса от спинлока в том, что мьютекс _блокирует_ поток, который ожидает захвата блокировки.

Требования:

* Захват и освобождение мьютекса, на владение которым больше никто не претендует, должен происходить максимально быстро, без переключения в ядро операционной системы..

* Если поток не может захватить блокировку, потому что его опережают другие потоки (такую ситуацию называют _contention_), то он должен _заблокироваться_ до освобождения мьютекса и освободить процессор.

Шаблон решения – [`mutex.hpp`](mutex.hpp).

## Фьютекс

Реализовать блокировку потока операционной системы целиком в пространстве пользователя невозможно, за исполнение потока отвечает планировщик операционной системы.

За блокировки в Linux отвечает _futex_ – ядерная очередь спящих потоков, которая привязана к ячейке памяти в адресном пространстве пользователя. 

Пользователь работает с фьютексом через одноименный системный вызов – [futex](http://man7.org/linux/man-pages/man2/futex.2.html).

- http://man7.org/linux/man-pages/man2/futex.2.html
- [Basics of Futexes](https://eli.thegreenplace.net/2018/basics-of-futexes/)

## `atomic::wait`

Начиная с С++20, с фьютексом можно работать через методы атомиков: [`wait`](https://en.cppreference.com/w/cpp/atomic/atomic/wait) + `notify_one` / `notify_all`

Изучите документацию этих методов!

Можно считать, что вызовы `wait` и `notify_{one,all}` - атомарны относительно друг друга: в ядре при работе с фьютексом берется ядерный спинлок.

При этом `wait` нельзя считать атомарным относительно вызова `store`!

## Ограничения

Фьютекс работает только с 32-битными словами в пространстве пользователя, так что используйте в реализации `atomic<uint32_t>`.
