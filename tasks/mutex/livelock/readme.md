## Livelock

Изучите реализацию [`TrickyLock`](tricky_lock.hpp).

Реализация использует RMW (_read_-_modify_-_write_) операции [fetch_add](https://en.cppreference.com/w/cpp/atomic/atomic/fetch_add) и [fetch_sub](https://en.cppreference.com/w/cpp/atomic/atomic/fetch_sub). 

Нетрудно убедиться, что `TrickyLock` гарантирует взаимное исключение.

Но помимо взаимного исключения (*safety*, никогда не случается ничего плохого) спинлок должен гарантировать еще и прогресс (*liveness*, однажды случится что-то хорошее): если несколько потоков хотят захватить свободный спинлок, то один из них обязательно завершит свой вызов `.Lock()`.

В этой задаче вам нужно построить исполнение, в котором потоки бесконечно долго не могут захватить свободный `TrickyLock`.

## Планировщик

Разумеется, мы считаем, что планировщик ведет себя _честно_: если у потока остаются невыполненные инструкции, то планировщик eventually поставит его на процессор. Это требование важно для определения прогресса спинлока.

Нас не беспокоит реалистичность поведения планировщика в искомом исполнении. Мы говорим о гарантии прогресса для алгоритма взаимного исключения, и эта гарантия должна соблюдаться при _любом_ честном поведении планировщика.  

## Моделирование

В файле `test.cpp` вы найдете код, в котором в цикле выполняется захват и освобождение лока. Внутри этого цикла дана развертка методов `Lock` и `Unlock` `TrickyLock`-а, а также критическая секция.

В коде используются неатомарные инкременты и декременты, поскольку пример построен на кооперативных потоках, которые вы уже видели в задаче про дэдлоки.

Вы должны вставить в тело цикла переключения потоков (вызовы `Yield`) таким образом, чтобы потоки угодили в лайвлок. Разрешается вставлять только единичные вызовы `Yield`, писать новые циклы и условную логику нельзя.

Файл [tricky_lock.hpp](tricky_lock.hpp) менять не нужно, он дан лишь для ознакомления с алгоритмом.

## Yield

Напомним семантику `Yield()` – передать управление планировщику и поместить текущий файбер (кооперативный поток) в хвост очереди на исполнение в планировщике.

## Тестирование

Если вы не лишены любопытства, то разберитесь, как устроено тестирование в этой задаче. Придумать тест в данном случае – интереснее, чем придумать решение самой задачи.
