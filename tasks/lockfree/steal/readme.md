# Work-Stealing Queue

Реализуйте [`WorkStealingQueue`](work_stealing_queue.hpp), которая послужит локальной очередью задач для воркеров [шардированного планировщика](/tasks/fibers/scheduler) файберов / корутин. 

Очередь реализована через циклический буфер. Емкость очереди / размер буфера задается через параметр шаблона.

Очередь хранит указатели на данные, а не сами данные.

## Операции

- `bool TryPush(T* item)` – если в очереди есть свободные слоты, то добавить в хвост очереди новый элемент и вернуть `true`. Если буфер очереди переполнился, то вернуть `false`.
- `T* TryPop()` – извлечь элемент (указатель) из головы очереди. Если очередь пуста, то вернуть `nullptr`.
- `size_t Grab(std::span<T*> out_buffer)` – забрать пачку элементов из головы очереди, переложив их в `out_buffer`, вернуть число извлеченных элементов.

## Паттерн доступа

Паттерн доступа – _Single Producer_ / _Multiple Consumers_:
- `TryPush` вызывает только один выделенный поток. 
- `TryPop` и `Grab` могут вызываться конкурентно из нескольких потоков.

В случае планировщика 
- `TryPush` и `TryPop` использует поток-воркер, владеющий очередью, 
- `Grab` используется 
  * другими воркерами для воровства задач, 
  * самим воркером для выгрузки задач в общую очередь при переполнении локальной.

## Требования

- Lock-freedom
- Установите в реализации оптимальные `memory_order`-ы.
