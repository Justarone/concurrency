# Мьютекс

## Пререквизиты

- [fibers/coroutine](/tasks/fibers/coroutine)
- [mutex/mutex](/tasks/mutex/mutex)
- [condvar/condvar](/tasks/condvar/condvar)

---

Реализуйте примитивы синхронизации для файберов:
- Мьютекс ([`Mutex`](exe/fibers/sync/mutex.hpp))
- Условную переменную ([`CondVar`](exe/fibers/sync/condvar.hpp))
- [`WaitGroup`](exe/fibers/sync/wait_group.hpp)

Методы `Mutex::Lock`, `CondVar::Wait` и `WaitGroup::WaitIdle` должны блокировать только вызывающий их файбер, но не блокировать поток планировщика, в котором этот файбер исполняется.

## Пример

```cpp
void SyncExample() {
  using namespace exe;
  
  tp::ThreadPool scheduler{/*threads=*/4};
  
  fibers::Go(scheduler, []() {
    fibers::Mutex mutex;
    size_t cs{0};
    
    // https://gobyexample.com/waitgroups
    fibers::WaitGroup wg;
    
    for (size_t i = 0; i < 123; ++i) {
      wg.Add(1);
      
      fibers::Go([&]() {
        // При завершении процедуры будет вызван wg.Done()
        // https://gobyexample.com/defer
        wheels::Defer defer([&wg]() {
          wg.Done();
        });
        
        for (size_t j = 0; j < 1024; ++j) {
          std::lock_guard guard(mutex);
          ++cs;  // <-- в критической секции
        }
      });
    }
    
    // Дожидаемся завершения всех запущенных файберов
    wg.Wait();
    
    std::cout << cs.load() << std::endl;
    // <-- Напечатано 123 * 1024
  });
}
```

## `FutexLike`

Реализация примитивов синхронизации не будет отличаться от реализации этих же примитивов для потоков, вы можете перенести реализации из уже решенных задач.

Но в этот раз у вас не будет фьютекса. Для файберов его придется реализовать самостоятельно.

Реализуйте класс [`FutexLike<T>`](exe/fibers/sync/futex.hpp) – очередь ожидания для файберов, привязанная к атомику (ссылка на атомик передается в конструктор `FutexLike`).

Методы:

* `ParkIfEqual(T old)` – атомарно (относительно конкурирующих вызовов `WakeOne` / `WakeAll`) сравнить текущее значение атомика с `old` и в случае равенства запарковать текущий файбер в очереди ожидания.
* `WakeOne` / `WakeAll` – разбудить один / несколько запаркованных файберов

### Реализация `FutexLike`

[kernel/futex/waitwake.c](https://github.com/torvalds/linux/blob/master/kernel/futex/waitwake.c)

#### Аллокации

В реализации фьютекса не должно быть динамических аллокаций. Используйте [интрузивный список](https://gitlab.com/Lipovsky/wheels/-/blob/master/wheels/support/intrusive_list.hpp), узлы для него аллоцируйте на стеках файберов.

#### Синхронизация

Для синхронизации доступа к состоянию фьютекса из конкурентных вызовов `ParkIfEqual` и `WakeOne` / `WakeAll` используйте [спинлок]().

#### Гонка

В `ParkIfEqual` вам потребуется разрешить гонку между `Suspend` и `Resume` файбера.

Для этого адаптируйте под фьютекс функцию `Suspend`.

## `Suspend`

Блокировка файбера на примитиве синхронизации на основе фьютекса – лишь частный случай общей задачи: файберу нужно остановиться и запланировать свое возобновление.
 
Примеры:
- `ParkIfEqual` на фьютексе: запланировать возобновление – значит положить себя в очередь ожидания, из которой нас потом достанут в вызовах `WakeOne` / `WakeAll` и запустят.
- `Yield`: тут файбер моментально планирует себя в пул потоков.
- Синхронный `Await` на `Future`: запланировать возобновление – подписаться на фьючу с помощью `Subscribe` и запустить себя в коллбэке.
- `Select` на нескольких каналах

### Универсальность

В этой задаче мы хотим придумать универсальный `Suspend`, который подойдет для всех перечисленных выше применений.

Универсальность состоит в том, что файберу не нужно знать про конкретные примитивы синхронизации и блокирующие операции, которые с ним работают, про детали их реализации (например, про спинлок фьютекса).

### Awaiters

Первое решение – кастомизировать для `Suspend` логику планирования возобновления файбера с помощью внешней (по отношению к файберу) стратегии, которую определяет конкретный примитив синхронизации / блокирующая операция.

Эту стратегию будем называть _awaiter_-ом.

[Understanding operator co_await](https://lewissbaker.github.io/2017/11/17/understanding-operator-co-await)

### Автомат

Альтернативное решение – обойтись `Suspend`-ом без аргументов, но тогда придется разрешить гонку между `Suspend` / `Resume` внутри файбера.

Попробуйте сделать это с помощью wait-free автомата.

Использовать взаимное исключение для разрешения гонки нельзя.

## `Yield`

Выразите функцию `Yield` через `Suspend`.

В самом классе `Fiber` знания про `Yield` быть не должно.

## Аллокации

В вашей реализации фьютекса (примитивов на его основе) не должно быть динамических аллокаций памяти.

- Контейнеры из `std` – аллокации.
- Заворачивание лямбды в `std::function` или подобный контейнер с type erasure – аллокация.

Если ваша реализация планировщика поддерживает интрузивные задачи, то единственные динамические аллокации в рантайме файберов – это аллокации самого файбера.

## `WaitGroup`

Бонусный уровень!

Счетчик `WaitGroup` тривиально реализуется с помощью мьютекса и кондвара.

Реализуйте `WaitGroup` с помощью атомиков и `FutexLike` так, чтобы в `Add` и на быстром пути в `Done` была всего лишь одна атомарная операция. 

Вам пригодится идея решения задачи про барьер.

<details>
<summary>Как не стоит делать</summary>

```cpp
void WaitGroup::Wait() {
  while ((size_t curr = counter_.load()) > 0) {
    // Семантика `ParkIfEqual` не подходит WaitGroup
    // Если значение счетчика часто меняется, то 
    // файбер может вообще не уснуть!
    waiters_.ParkIfEqual(curr);
  }
}
```
</details>

## Lock-free Mutex

Бонусный уровень!

Реализуйте `Mutex` без использования взаимного исключения между _потоками_ планировщика (а значит без `FutexLike`), с помощью
лок-фри стека.

Лок-фри реализация потребует расширения протокола Awaiter-а.

### Серийный мьютекс

Реализуйте серийный запуск критических секций в лок-фри мьютексе.

## Шаги

1) Реализуйте `FutexLike`. Функцию `Suspend` для начала можно подстроить под него.
2) Реализуйте через фьютекс примитивы синхронизации: `Mutex`, `CondVar` и `WaitGroup`
3) Реализуйте универсальный `Suspend` с awaiter-ом или через wait-free автомат
4) Выразите `Yield` через `Suspend`
5) Бонусный уровень: реализуйте `WaitGroup` на атомиках
6) Бонусный уровень: реализуйте lock-free мьютекс
7) Бонусный уровень: реализуйте серийный запуск критических секций в мьютексе

## Misc

В коде `fibers/core` не должно быть знания о деталях реализации конкретных примитивов синхронизации. В частности, файбер не должен знать про спинлок фьютекса.

Использовать внутри `Fiber` взаимное исключение нельзя.

Менять API пула потоков не нужно, файберы по-прежнему используют только метод `Submit`.

Класс `Fiber` – деталь реализации, он не должен быть виден пользователю через публичное API.
