# Мьютекс

## Пререквизиты

- [fibers/coroutine](/tasks/fibers/coroutine)
- [fibers/sleep_for](/tasks/fibers/sleep_for)
- [mutex/mutex](/tasks/mutex/mutex)
- [condvar/condvar](/tasks/condvar/condvar)

---

Реализуйте примитивы синхронизации для файберов:
- Мьютекс ([`Mutex`](exe/fibers/sync/mutex.hpp))
- Условную переменную ([`CondVar`](exe/fibers/sync/condvar.hpp))
- [`WaitGroup`](exe/fibers/sync/wait_group.hpp)

Методы `Mutex::Lock`, `CondVar::Wait` и `WaitGroup::Wait` должны блокировать только вызвавший их файбер, но не блокировать поток планировщика, в котором этот файбер исполняется.

## Пример

```cpp
void SyncExample() {
  using namespace exe;
  
  tp::ThreadPool scheduler{/*threads=*/4};
  
  fibers::Go(scheduler, []() {
    fibers::Mutex mutex;
    size_t cs{0};
    
    // https://gobyexample.com/waitgroups
    fibers::WaitGroup wg;
    
    for (size_t i = 0; i < 123; ++i) {
      wg.Add(1);
      
      fibers::Go([&]() {
        // При выходе из скоупа будет вызван wg.Done()
        // https://gobyexample.com/defer
        wheels::Defer defer([&wg]() {
          wg.Done();
        });
        
        for (size_t j = 0; j < 1024; ++j) {
          std::lock_guard guard(mutex);
          ++cs;  // <-- в критической секции
        }
      });
    }
    
    // Дожидаемся завершения всех запущенных файберов
    wg.Wait();
    
    std::cout << cs.load() << std::endl;
    // <-- Напечатано 123 * 1024
  });
}
```

## `FutexLike`

Реализация примитивов синхронизации не будет отличаться от реализации этих же примитивов для потоков, вы можете перенести реализации из уже решенных задач.

Но в этот раз у вас не будет фьютекса. Для файберов его придется реализовать самостоятельно.

Реализуйте класс [`FutexLike<T>`](exe/fibers/sync/futex.hpp) – очередь ожидания для файберов, привязанная к произвольному атомику.

API:

* Конструктор `FutexLike` принимает ссылку на атомик.
* `ParkIfEqual(T old)` – атомарно (относительно конкурирующих вызовов `WakeOne` / `WakeAll`) сравнить текущее значение атомика с `old` и в случае равенства запарковать текущий файбер в очереди ожидания.
* `WakeOne` / `WakeAll` – разбудить один / несколько запаркованных файберов

### Реализация `FutexLike`

[kernel/futex/waitwake.c](https://github.com/torvalds/linux/blob/master/kernel/futex/waitwake.c)

#### Спинлок

Для синхронизации доступа к очереди файберов из конкурентных вызовов `ParkIfEqual` и `WakeOne` / `WakeAll` используйте [спинлок](exe/support/spinlock.hpp).

#### Гонка

В `ParkIfEqual` вам потребуется разрешить гонку между `Suspend` и `Resume` файбера.

Для этого адаптируйте под фьютекс функцию `Suspend`.

## `Suspend`

Блокировка файбера на примитиве синхронизации на основе фьютекса – лишь частный случай общей задачи: файберу нужно остановиться и запланировать свое возобновление.
 
Примеры:
- `ParkIfEqual` на фьютексе: запланировать возобновление – значит положить себя в очередь ожидания, из которой нас потом достанут и запустят в вызове `WakeOne` / `WakeAll`.
- `Yield`: тут файбер моментально планирует себя в пул потоков.
- Блокирующий `Await` на `Future`: запланировать возобновление – подписаться на готовность `Future` с помощью `Subscribe` и запустить себя в коллбэке.
- `Select` на каналах

### Гонка

Во всех этих примерах есть потенциальная гонка между возобновлением файбера и его остановкой.

### Универсальность

В этой задаче мы хотим придумать универсальный `Suspend`, который подойдет для всех перечисленных выше применений.

Файбер не должен знать про конкретные примитивы синхронизации и блокирующие операции, которые с ним работают, про детали их реализации (например, про спинлок фьютекса).

### Awaiters

Решение – кастомизировать для `Suspend` планирование возобновления файбера с помощью внешней (по отношению к файберу) стратегии, которую определяет конкретный примитив синхронизации / блокирующая операция.

Эту стратегию мы назовем _Awaiter_.

[Understanding operator co_await](https://lewissbaker.github.io/2017/11/17/understanding-operator-co-await)

### `FiberHandle`

Awaiter работает с _остановленным_ файбером через [`FiberHandle`](exe/fibers/core/handle.hpp).

Непрозрачный `FiberHandle` позволит избавиться в реализации `FutexLike` от непосредственного доступа к объекту `Fiber`, скрыть его от пользователя.


## `Yield`

Выразите через `Suspend` функцию `Yield`. 

Так вы убедитесь, что получившийся `Suspend` подходит для разных задач.

## Аллокации

### `FutexLike`

В вашей реализации фьютекса не должно быть динамических аллокаций памяти.

Используйте [`wheels::IntrusiveList`](https://gitlab.com/Lipovsky/wheels/-/tree/master/wheels/intrusive/list.hpp).

Заворачивание лямбды в `std::function` или подобный контейнер с type erasure – тоже динамическая аллокация.

### Планировщик

Если ваша реализация планировщика поддерживает интрузивные задачи, то единственными динамическими аллокациями в рантайме файберов окажутся аллокации самого объекта `Fiber`.

## Синхронизация

В классе `Fiber` не должно быть дополнительной синхронизации: ни взаимного исключения, ни ожидания других потоков.

## `WaitGroup`

Бонусный уровень!

Реализуйте `WaitGroup` только лишь с помощью атомиков и `FutexLike` так, чтобы в `Add` и на быстром пути в `Done` была всего лишь одна атомарная операция. 

Вам пригодится идея решения задачи про барьер.

<details>
<summary>Как не стоит делать</summary>

```cpp
void WaitGroup::Wait() {
  while ((size_t curr = counter_.load()) > 0) {
    // Семантика `ParkIfEqual` не подходит WaitGroup
    // Если значение счетчика часто меняется, то 
    // файбер может вообще не уснуть!
    waiters_.ParkIfEqual(curr);
  }
}
```
</details>

## Lock-free Mutex

Бонусный уровень!

Реализуйте `Mutex` без использования взаимного исключения между _потоками_ планировщика (а значит без `FutexLike`), с помощью
лок-фри стека.

Лок-фри реализация потребует расширения протокола awaiter-а.

### Серийный мьютекс

Реализуйте серийный запуск критических секций в лок-фри мьютексе.

## Шаги

1) Реализуйте `FutexLike`. Функцию `Suspend` для начала можно подстроить под него.
2) Реализуйте через фьютекс примитивы синхронизации: `Mutex`, `CondVar` и `WaitGroup`.
3) Реализуйте универсальный `Suspend` с awaiter-ом.
4) Улучшите свою реализацию `FutexLike`: избавьтесь от аллокаций, спрячьте `Fiber`.
5) Выразите `Yield` через `Suspend`.
6) Бонусный уровень: реализуйте `WaitGroup` на атомиках.
7) Бонусный уровень: реализуйте lock-free мьютекс.
8) Бонусный уровень: реализуйте серийный запуск критических секций в мьютексе.

## Misc

Менять API пула потоков не нужно, файберы по-прежнему полагаются для планирования только на метод `Submit`.
