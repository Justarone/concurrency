# Futures / Promises

## Пререквизиты

- [futures/executors](/tasks/futures/executors)

---

## Канал

В первом и очень грубом приближении _futures_ / _promises_ реализуют канал для возврата значения из асинхронной операции.

У этого канала два конца: `Promise<T>` – для записи, `Future<T>` – для чтения.

```cpp
// Где-то в программе:
// Разворачиваем канал
// `promise` отправится потоку `A` (producer), фьюча - потоку `B` (consumer)
Promise<int> promise;
auto future = promise.MakeFuture();

// Альтернативный вариант:
// auto [future, promise] = MakeContract<int>();

// В потоке A:
// Отправляем значение, "комплитим" (от complete) фьючу
std::move(promise).SetValue(42);
// Альтернативно можно было бы отправить ошибку, например, текущее исключение:
// std::move(promise).SetError(std::current_exception());

// В потоке B:
// "Распаковываем" фьючу, блокируем _поток_ до появления результата (значения / ошибки)
Result<int> result = std::move(future).GetResult();
// Можно использовать метод `GetValue()`, который сразу развернет полученный Result 
// с помощью ValueOrThrow()
```

### One-Shot

Записать в Promise значение / распаковать фьючу можно _только один раз_.

Чтобы подчеркнуть это ограничение, привяжем к _rvalue_ все вызовы, которые приводят к поглощению значения `Future` (и симметрично для `Promise`):

```cpp
template <typename T>
T Future<T>::GetResult() && {  // метод `GetResult` можно звать только на rvalue
    // ...
}
```

Пример:

```cpp
auto f = FetchHttp(url);
auto content = std::move(f).GetResult();
```

Теперь можно пользоваться проверкой [`bugprone-use-after-move`](https://clang.llvm.org/extra/clang-tidy/checks/bugprone-use-after-move.html) в `clang-tidy`.

### Thread-safety

Канал, образованный парными `Promise`/`Future`, – _потокобезопасен_, поток-продьюсер и поток-консьюмер могут конкурентно вызывать `SetValue` / `GetResult` на своем конце канала.

Но сами по себе `Future` и `Promise` – _не потокобезопасны_, каждым концом канала владеет и оперирует только один поток.

## AsyncVia

С помощью фьюч легко реализовать поверх экзекуторов функциональность возврата значения / ошибки из задачи:

```cpp
auto tp = MakeStaticThreadPool(4, "tp");

auto compute = []() -> int {
    ExpectThread("tp");
    return 42;
}

// Запускаем вычислительную задачу в пуле потоков `tp` и
// блокируемся до получения результата:
std::cout << AsyncVia(tp, compute).GetValue() << std::endl;
```

## Источники фьюч

* Таймаут ([`After`](await/futures/util/after.hpp))
* Вычислительная задача в пуле потоков ([`AsyncVia`](await/futures/util/async.hpp))
* [Remote Procedure Call](http://dist-prog-book.com/chapter/1/rpc.html) к внешнему сервису
* Чтение с диска

## Абстракция и композиция

Взгляд на `Future<T>` как на канал – слишком упрощенный.

`Future<T>` – _представление будущего результата_ асинхронной операции, 

Такой взгляд на фьючи открывает дорогу к функциональной композиции асинхронных вычислений: [Marius Eriksen – Your Server as a Function](https://monkey.org/~marius/funsrv.pdf)

### `Then` (последовательная композиция)

Будущий результат можно передать в следующую по цепочке вызовов функцию, не дожидаясь его материализации:

```cpp
// Foo - T(), Bar - U(T)

// Запускаем `Foo` в пуле потоков
Future<T> f = AsyncVia(tp, Foo);

// "Передаем" будущий результат `f` в вызов `Bar`
// Функция Bar ожидает значения типа T, а не фьючу
// Связывание происходит внутри комбинатора `Then`
// Future<T> -> U(T) -> Future<U>
Future<U> g = std::move(f).Then(Bar); 
```

Функция, переданная в `Then`, называется _продолжением_ (_continuation_). Продолжение получает единственным аргументом значение типа `T` и возвращает значение произвольного типа `U`.

Продолжение "поглощает" будущий результат, который представляет фьюча, после вызова `Then` обращаться к исходной фьюче нельзя.

Вызов `Then` – неблокирующий, он не приводит к синхронному ожиданию значения и синхронному вызову продолжения, он _планирует_ вызов продолжения после готовности фьючи.

#### Chaining

С помощью `Then` можно [fluently](https://en.wikipedia.org/wiki/Fluent_interface) выстраивать цепочки продолжений произвольной длины:

```cpp
// Стартуем асинхронный пайплайн
AsyncVia(tp, first)
  .Then(second)
  .Then(third)
  .Subscribe(Last);  // Терминируем цепочку
```

#### Асинхронные продолжения

Продолжение может быть асинхронным, т.е. может возвращать не просто `U`, а `Future<U>`.

Этот случай требуется обработать отдельно: продолжение, следующее в цепочке за асинхронным продолжением, должно получить на вход не `Future<U>`, а `U`.

#### Обработка ошибок

Сигнатура продолжения `U(T)` не позволяет ему получить и обработать ошибку, возникшую на предшествующем шаге цепочки.

Ошибка, возникшая на одном из шагов, будет "пролетать" сквозь последующие `Then`, без вызова соответствующих продолжений:

```cpp
auto crash = []() -> int {
  throw std::runtime_error("Something goes wrong");
};

auto second = [](int value) {
  return value * 2;
};

auto third = [](int value) {
  return value + 1;
};

AsyncVia(tp, crash)
  .Then(second)  // Не будет вызван
  .Then(third)   // Не будет вызван
  .Subscribe([](Result<int> result) {
    // result.HasError() == true
  });
```

Для восстановления после ошибок стоит использовать комбинатор `Recover`:

```cpp
// T(Error)
auto handle_error = [](Error /*error*/) -> int {
  return 42;
};

AsyncVia(tp, crash)
  .Then(second)  // Не будет вызван
  .Then(third)   // Не будет вызван
  .Recover(handle_error)  // перехватит ошибку
  .Subscribe([](Result<int> result) {
    // result.IsOk() == true
    // *result == 42
  });
```

В отличие от `Then`, которые не вызываются на ошибках, `Recover` симметрично не вызывается на значениях.

И `Then`, и `Recover` выражаются через более общий комбинатор `Transform`: `Future<T>` ⭢ `Result<U>(Result<T>)` ⭢ `Future<U>` (+ асинхронная вариация для `Future<U>(Result<T>)`).

#### Монады

`Then` связывает вычисления в цепочку: будущее значение `Future<T>`, полученное на предыдущем шаге, нужно связать с продолжением, которое ожидает на вход обычное значение `T`.

Аналогичная задача решается при обработке ошибок, см. [`expected<T, E>`](https://github.com/TartanLlama/expected)

В обоих случаях у нас есть контейнер для значения и логика связывания вычислений. Эти точки кастомизации образуют понятие _монады_, см. [All About Monads](https://wiki.haskell.org/All_About_Monads).

### Параллельная композиция

Возможности комбинирования фьюч не исчерпываются цепочками продолжений (т.е. последовательной композицией):

#### `All`

Собираем все результаты под одной фьючей:
```cpp
template <typename T>
Future<std::vector<T>> All(std::vector<Future<T>> inputs);
```

#### `FirstOf`

Дожидаемся первого результата:
```cpp
template <typename T>
Future<T> FirstOf(std::vector<Future<T>> inputs);
```

Комбинаторы составляют целый [декларативный язык](https://rufflewind.com/2017-05-15/futures-cheatsheet), на котором пользователь описывает свои конкурентные активности.

### Файберы и фьючи

Можно заметить, что с последовательной композицией асинхронных операций гораздо лучше справляются файберы:
вместо декларативных цепочек из `Then` и `Recover` можно было бы писать обычные синхронные вызовы и использовать исключения.

Но файберы плохо справляются с параллельной композицией, тут декларативный язык комбинаторов `All` и `FirstOf` оказывается более выразительным.

Вывод: файберы и фьючи - не исключающие друг друга альтернативы, а равноправные инструменты, которые следует комбинировать друг с другом для максимальной выразительности.

### Subscribe

Внутренняя механика продолжений и комбинаторов – _коллбэки_:

```cpp
Future<int> f = AsyncVia(tp, compute);

// Подписываемся на результат фьючи
// Вызов `Subscribe` завершается без блокировки до вызова коллбэка
std::move(f).Subscribe([](Result<int> result) {
  if (result.IsOk()) {
    std::cout << "Result: " << *result << std::endl;
  } else {
    std::cout << "Computation failed" << std::endl;
  }
}
```

Коллбэк поглощает результат фьючи, так что к фьюче можно подвесить только один коллбэк, после чего обращаться к ней больше нельзя.

### Неблокирующие операции

В асинхронном мире блокирующие методы `GetValue` / `GetResult` практически бесполезны.

Асинхронный код – _event-driven_, каждый следующий шаг запускается по мере готовности предыдущего. Именно такое неблокирующее поведение и реализуют комбинаторы через подписку на результат, т.е. через `Subscribe`.

## Гонка

Рассмотрим следующий пример:

```cpp
// Ранее: [f, p] = MakeContract<int>();

// В потоке A:
std::move(p).SetValue(42);

// В то же время в потоке B:
std::move(f).Subsribe(callback);
```

Вызовы `Subscribe` и `SetValue` гоняются друг с другом, неизвестно, что случится раньше – установка коллбэка или значения. А от этого в свою очередь зависит в каком потоке будет вызван коллбэк.

Эта неопределенность может привести к неприятным последствиям:

Пусть библиотека _L_ реализует некоторую асинхронную функцию. Пользователь вызвал эту функцию, получил фьючу и подвесил к ней тяжелое вычисление, после чего про фьючу забыл. Когда библиотека _L_ будет комплитить фьючу, то ей придется запустить в собственном внутреннем потоке пользовательский коллбэк с тяжелым вычислением.

### Экзекуторы

Пользователь, планирующий с помощью фьюч цепочку асинхронных действий, должен иметь контроль на тем, в каких потоках эти действия будут выполняться. И здесь ему на помощью приходят _экзекуторы_.

Продолжение (или произвольный коллбэк) можно запланировать на запуск в конкретном экзекуторе с помощью метода `Via`:

```cpp
// Пул потоков для запуска вычислительных задач
auto cpu_tp = MakeStaticThreadPool(4, "cpu");

// Запускаем распаковку в пуле потоков `cpu_tp`
auto f = Fetch(url).Via(cpu_tp).Then(Decompress);
```

Установленный через `Via` экзекутор наследуется по всей цепочке продолжений:
```cpp
// Вызовы `a` -> `b` -> `c` будут исполняться экзекутором `e1`
// Вызовы `d` -> `last` будут выполнены в экзекуторе `e2`
std::move(f)
  .Via(e1).Then(a).Then(b).Then(c)
  .Via(e2).Then(d).Subsribe(last);
```

## SemiFuture / ContinuableFuture

API фьюч можно усовершенствовать: статически запретить "передавать" фьючу в следующей по цепочке вызов без явного указания экзекутора.

В [Folly/Futures](https://github.com/facebook/folly/blob/master/folly/docs/Futures.md) фьюча может принимать две формы:

* `Future<T>` – фьюча, которая уже ассоциирована с экзекутором, ее можно связать с продолжением
* `SemiFuture<T>` – фьюча, с которой можно работать только синхронно _либо_ трансформировать ее в `Future<T>` с помощью `Via`

[Future vs. SemiFuture](https://github.com/facebook/folly/blob/e270048526d5c65f6dcba13c6e1d5045398847de/folly/futures/Future.h#L466)

```cpp
// Неполноценная фьюча
auto semi_future = FetchHttp(url);

// Можно:
// auto data = std::move(semi_future).Get();
// Нельзя:
// std::move(semi_future).Then(ParseJson);

// Трансформируем в полноценную фьючу с помощью `Via` и строим пайплайн
auto std::move(semi_future).Via(e).Then(ParseJson).Then(ProcessJson);
```

Публичные API должны возвращать своим клиентам только `SemiFuture<T>`.

## Future / Promise

Может показаться, что разделение на две сущности `Promise` и `Future` не обязательное и избыточное.

На практике разработчик прикладного асинхронного кода работает лишь с read-only фьючами и комбинаторами. Все возникающие по пути промисы и `Set`-ы - это изнанка фьюч, они спрятаны в реализации комбинаторов и асинхронных сервисов, генерирующих фьючи.

## Фьючи и корутины в С++

Фьючи интегрируются с корутинами:
1) Их можно ждать с помощью `co_await` (подобие do-нотации для монад из Haskell)
2) Их можно использовать для комбинирования корутинных и не-корутинных вызовов

[CppCon 2017: Gor Nishanov “Naked coroutines live (with networking)”](https://www.youtube.com/watch?v=UL3TtTgt3oU)

## Декларативность / среда исполнения

С помощью комбинаторов пользователь _декларативно_ описывает графы своих конкурентных активностей, а _экзекуторы_ исполняют их на ограниченном наборе потоков.

## Проблемы абстракции

* Вместо программирования на языке программирования пользователь вынужден программировать на языке комбинаторов. Декларативность этого языка становится препятствием для выражения простых императивных конструкций: циклов и ветвлений.

* Фьючи не дают удобных инструментов для отмены асинхронных операций, поскольку нужно отправить "сигнал" в неестественном для фьюч направлении: от консьюмеров к продьюсерам.

* Сама абстракция `Future`/`Promise` содержит гонку между продьюсером и консьюмером, что требует аллокации на куче, атомарного подсчета ссылок и синхронизации.

## References

- [Your Server as a Function](https://monkey.org/~marius/funsrv.pdf), [Finagle – Concurrent Programming with Futures](https://twitter.github.io/finagle/guide/Futures.html)
- [Futures for C++11 at Facebook](https://engineering.fb.com/developer-tools/futures-for-c-11-at-facebook/), [Folly Futures](https://github.com/facebook/folly/blob/master/folly/docs/Futures.md),
- [Zero-cost futures in Rust](http://aturon.github.io/blog/2016/08/11/futures/), [Designing futures for Rust](http://aturon.github.io/blog/2016/09/07/futures-design/)

## Задание

1) Реализуйте блокирующую функциональность фьюч: вариации `Set`-ов и `Get`-ов
2) Реализуйте `AsyncVia`
3) Реализуйте метод `Subscribe`
4) Реализуйте продолжения: две перегрузки `Transform` для синхронных и асинхронных продолжений
4) Реализуйте комбинаторы `All` и `FirstOf`

## Замечания по реализации

Вместо специализации для `void` предлагается с чуть меньшим комфортом работать с `Future<Unit>`.

Используйте `wheels::UniqueFunction`, которая умеет оборачивать move-only лямбды.

В реализации будет много служебных лямбд-замыканий, которые захватывают `Promise`-ы. Маркируйте такие лямбды как `mutable`.

Перемещайте, а не копируйте `Result<T>` в шаблонном коде, тип `T` может не поддерживать копирование.

Если вам нужно вызвать функцию и завернуть ее возвращаемое значение / исключение в `Result`, то используйте `wheels::make_result::Invoke`.

Предпочитайте функцию `MakeContract` методу `MakeFuture`.

Избегайте дублирования кода в комбинаторах: общую логику поместите в функцию [`Combine`](await/futures/combine/detail/combine.hpp), специфичную для комбинатора – в соответствующий класс-комбинатор.

Не пишите в заголовочных файлах (не важно, `.hpp` или `.ipp`) `using`-и, иначе они попадут и пользователю.

### `GetResult`

Фьюча должна поддерживать блокирующий `GetResult`, для его реализации потребуется мьютекс + кондвар.

Но основной способ применения фьюч – неблокирующий, т.е. использование `Subscribe` / `Then`.

Не добавляйте мьютекс и кондвар в поля `SharedState`.

Для синхронизации `Set` / `Subscribe` используйте лок-фри автомат, его можно построить на одном атомике.

См. [автомат в фьючах из `folly`](https://github.com/facebook/folly/blob/e9a24429e17e85539143fb4192d22ac89f012906/folly/futures/detail/Core.h#L247).

## `std::`

- `std::function` не поддерживает move-only лямбды, из которых состоит реализация фьюч
- `std::future` не поддерживает продолжения / коллбэки
