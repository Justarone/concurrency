# Executors

## Выразительные средства / среда исполнения

[Коллбэки](https://github.com/chriskohlhoff/asio/blob/master/asio/src/examples/cpp14/echo/async_tcp_echo_server.cpp), [фьючи](https://github.com/facebook/folly/blob/master/folly/docs/Futures.md), [файберы](https://gitlab.com/Lipovsky/tinyfiber), [stackless корутины](https://en.cppreference.com/w/cpp/language/coroutines) – это различные _выразительные средства_ асинхронного программирования.

С помощью этих средств разработчик может описать конкурентные активности в своей программе (например, обработку клиентских соединений) без использования блокирующего (поток) ожидания, что в свою очередь позволяет плотно упаковать эти активности в ограниченное число потоков операционной системы.

Но это лишь _выразительные средства_, и им требуется _среда исполнения_, т.е. набор потоков, которые будут непосредственно исполнять описанные конкурентные активности.

## Tasks (callbacks) are everywhere

С позиции _разработчика_, который пишет прикладной асинхронный код, перечисленные средства выразительности сильно отличаются друг от друга: достаточно сравнить реализацию простейшего сетевого приложения на _Asio_ и на файберах / корутинах.

Но несмотря на все внешние различия, с позиции _среды исполнения_ все эти выразительные средства выглядят одинаково:

И коллбэки _Asio_,  и файберы, и продолжения фьюч – все это _задачи_, которые нужно запускать на выделенном наборе потоков. Эти задачи при исполнении генерируют новые задачи, и исполнение тем самым бежит вперед.

## Декомпозиция и унификация

Сделанные выше наблюдения позволяют

1) Отделить конкретные _выразительные средства_ от _среды исполнения_ и
2) _унифицировать_ эту среду исполнения в виде фреймворка _экзекуторов_ (_executors_), поддержать в нем разные стратегии запуска задач.

## `IExecutor`

Асинхронный код не оперирует понятием потока, вместо этого он оперирует абстракцией _экзекутора_.

Функция экзекутора – исполнять _задачи_ – порции неблокирующего кода (коллбэки асинхронных операций, продолжения фьюч, файберы и т.д.).

Потоки, очереди, синхронизация – это внутренняя механика, скрытая от пользователя за простым интерфейсом: [`IExecutor`](await/executors/executor.hpp) 

Экзекутор предоставляет пользователю единственный метод `Execute(Task&& task)` – запланировать задачу на запуск:

```cpp
executor->Execute([]() {
  std::cout << "Hello!" << std::endl;
});
```

В каком потоке будет исполнена задача, когда именно – пользователя экзекутора эти вопросы беспокоить не должны. 

Экзекутор может владеть потоками и самостоятельно исполнять задачи, а может декорировать другой экзекутор и делегировать запуск задач ему.

#### `AsyncVia`

Экзекуторы - _one-way_, они не предоставляют механизма для возврата результата из задачи. 

Возврат результата не требует усложнения абстракции:

```cpp
// template <typename T>
// Future<T> AsyncVia(IExecutorPtr e, std::function<T()> target)

// Запускаем задачу в пуле потоков `thread_pool`
// и возвращаем caller-у фьючу, представляющую будущий результат
auto future = AsyncVia(tp, []() -> int { return 42; });
```

### Примеры

Приведем примеры интеграции экзекуторов и различных выразительных средств:

#### Файберы

_Файбер_ - это сумма следующих слагаемых:
1) _Корутина_
2) _Экзекутор_
3) _Задача_, которая запускается в экзекуторе, резьюмит корутину и перепланирует себя в экзекутор после ее (корутины) остановки.

```cpp
// Spawn(FiberRoutine body, IExecutorPtr executor);
// Запускаем файбер в экзекуторе `thread_pool` с помощью
Spawn(body, thread_pool);

// Где-то в теле файбера:

// Запускаем новый файбер в текущем экзекуторе
Spawn(child);

// Можем перепрыгнуть в другой пул потоков
// Вспомните реализацию `Yield` для многопоточных файберов
// и подумайте, как обобщить ее до телепортации
TeleportTo(another_thread_pool);
```

#### Фьючи

Фьючи представляют собой клей, с помощью которого можно выстраивать задачи в асинхронные пайплайны и графы.

В библиотеке [Folly](https://github.com/facebook/folly) для "передачи" фьючи в следующую по цепочке вызовов функцию (продолжение) требуется явно с помощью `via` задать экзекутор, в котором продолжение будет запущено:

```cpp
// Cм. https://github.com/facebook/folly/blob/master/folly/docs/Futures.md
// Когда фьюча `f` получит значение, то оно будет передано функции `foo`
// которая будет выполнена в экзекуторе `e`
std::move(f).via(e).thenValue(foo).thenValue(bar);
```

## Базовые экзекуторы

### Thread Pool

Пул из фиксированного числа потоков, разбирающих общую очередь задач.

```cpp
// Создаем пул из 4-х потоков, потоки пула маркируем именем "tp";
auto tp = MakeStaticThreadPool(4, "tp")

// Планируем задачу
tp->Execute([]() {
  ExpectThread("tp");  // Проверяем, что работаем в нужном пуле
  DoSomeWork();
});
```

#### Легкие и тяжелые задачи

Реализация пула зависит от природы задач, которые в нем будут исполняться.

Если пул используется для запуска тяжелых вычислительных задач, то простой реализации с общей очередью будет достаточно.

Если же пул используется как планировщик для файберов, т.е. для очень коротких задач, которые еще и интенсивно коммуницируют между собой с помощью каналов и примитивов синхронизации, то затраты на синхронизацию на общей очереди будут слишком заметны на фоне самих задач.

Эффективная реализация пула для файберов должна поддерживать отдельные очереди для каждого воркера и механизм балансировки нагрузки между ними, см. [work stealing](https://en.wikipedia.org/wiki/Work_stealing).

### Manual

Задачи, запланированные через _manual executor_, запускаются _вручную_ с помощью методов `RunAtMost(limit)`, `RunAtMostOne` и подобных:

```cpp
auto manual = MakeManualExecutor();

manual->Execute([]() {
  std::cout << "first task" << std::endl;
});
manual->Execute([]() {
  std::cout << "second task" << std::endl;
});

// К этому моменту ни одна из задач еще не запустилась

// Запустим первую в очереди задачу
manual->RunAtMostOne();

// Запустим вторую:
manual->RunAtMost(100);
```

Собственных потоков у manual executor нет.

Manual executor не потоко-безопасен!

См. [реализацию](await/executors/manual.cpp).

#### Тестирование

Manual executor замечательно подходит для написания детерминированных тестов.

В частности, с помощью него можно детерминированно тестировать код на файберах, что было бы невозможно с кодом на потоках:

```cpp
auto manual = MakeManualExecutor();

// Тело файбера
auto body = []() {
  // Step 1
  Yield();
  // Step 2
};

// "Запустили" файбер
Spawn(body, manual);

// Выполнили первый шаг файбера
manual->RunAtMostOnce();
```

### Inline

Запускает задачи прямо в вызове `Execute`:

```cpp
class InlineExecutor : public IExecutor {
 public:
  void Execute(Task&& task) override {
    try {
      task();
    } catch (...) {
      // Intentionally ignore exceptions
    }
  }
};
```

Такой экзекутор полезен как экзекутор по умолчанию для фьюч.

См. [реализацию](await/executors/inline.cpp)

## Декораторы

Экзекутор может не исполнять задачи самостоятельно, а декорировать другой экзекутор.

Экзекутор-декоратор не должен делать никаких дополнительных предположений об устройстве декорируемого им экзекутора. Например, нельзя рассчитывать, что задачи в нем исполняются асинхронно или в том порядке, в котором они были запланированы через `Execute`.

### Приоритеты

Первый пример декоратора – поддержка приоритетов для задач:

```cpp
auto tp = MakeStaticThreadPool(4, "tp");
// Декорируем пул потоков
auto pq = MakePriorityExecutor(tp);

pq->Execute(100, [](){
  // Очень важная задача, ее нужно выполнить в первую очередь
});

pq->Execute(-100, [](){
  // Эта задача должна уступать дорогу более важным
});
```

Priority executor дает следующую гарантию: когда декорируемый экзекутор запускет очередную задачу, то этой задачей должна быть самая приоритетная из запланированных, но еще не запущенных задач.

Если декорируемый экзекутор позволяет запускать задачи параллельно, то priority executor должен этим пользоваться.

Сам priority executor отправленные в него задачи не исполняет.

#### Пример

```cpp
auto tp = MakeStaticThreadPool(1, "tp");
auto pq = MakePriorityExecutor(tp);

pq->Execute(100, [pq](){
  // Задача A
  std::this_thread::sleep_for(1s);
  pq->Execute(100, []() {
    // Задача C
    // Будет запланирована после задачи B,
    // но будет исполнена _до_ B
  });
})

pq->Execute(-100, []() {
  // Задача B, низкоприоритетная
});
```

### Strand (Serial Executor)

Запускаемым в пуле задачам может потребоваться синхронизация. Использовать мьютексы нельзя: на время ожидания мьютекса задача заблокирует поток пула для других задач, которые лежат в очереди и готовы исполняться.

Чтобы избавиться от блокирующего ожидания в пуле потоков, экзекуторы предоставляют _асинхронный_ мьютекс – _strand_.

_Strand_ (или _serial executor_) – экзекутор, запускающий все задачи строго _последовательно в порядке их добавления_ (в том же смысле, как упорядочивает блокирующая очередь). 

Задачи, исполняемые strand-ом, можно назвать критическими секциями, но запускаются они асинхронно, вызов `Execute` возвращает управление пользователю моментально, без ожидания.

См. [Strands: Use Threads Without Explicit Locking](http://think-async.com/Asio/asio-1.16.0/doc/asio/overview/core/strands.html)

Strand – это декоратор, он не имеет собственных потоков для исполнения задач, он оборачивает произвольный экзекутор и запускает все задачи в нем.

Strand ничего не знает про число потоков, которые оказались в его распоряжении, и может запускать свои задачи в разных потоках, но выполняться эти задачи должны строго последовательно.

### Эффективность

Хорошая реализация strand-а с батчингом и лок-фри будет эффективнее мьютекса: критические секции исполняются сериями, синхронизация между секциями в пределах серии не требуется.

Чем больше нагрузка на strand, тем меньше будет в исполнении синхронизации и тем эффективнее будет исполняться код, в отличие от обычного мьютекса, в котором все наоборот!

### Примеры применения

#### Приоритеты для файберов

Если в приложении есть файберы, которые обслуживают запросы пользователей и файберы, выполняющие менее важные задачи, то разумно дать первым больший приоритет: 

```cpp
auto scheduler = MakeStaticThreadPool(4, "fibers");
auto pq = MakePriorityExecutor(tp);

// Экзекутор для высокоприоритетных файберов
auto high_priority = pq->FixPriority(100);
// Экзекутор для фоновых задач
auto low_pririoty = pq->FixPriority(0);

// Запускаем высокоприоритетный файбер
Spawn(body, high_priority);
```
При этом в реализацию файберов изменения вносить не потребуется, как и в базовый планировщик!

#### Взаимное исключение для файберов

Пусть разные файберы хотят обращаться к разделяемой структуре данных. Файберы могут запускаться на разных потоках пула, а значит при обращении к разделяемому состоянию им потребуется синхронизация.

Сложное решение – написать concurrent-версию структуры данных, с которой можно работать из разных потоков.

Простое решение – связать с этой структурой данных отдельный strand и телепортироваться в него при обращении. У strand-а асинхронный интерфейс, но для файберов его можно трансформировать в синхронный:

```cpp
// Где-то в теле файбера:
{
  // Аналогично std::lock_guard, но эффективнее!
  TeleportGuard guard(strand);  // Телепортируемся в strand
  
  // Теперь мы одни, можно обратиться к разделяемому состоянию
  AccessSharedState();
  
}  // Телепортируемся в исходный экзекутор
```

## Unified Executors for C++

- [A Unified Executors Proposal for C++](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p0443r12.html) – будущий дизайн экзекуторов в C++
- [Executors Bibilography](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p0443r12.html#appendix-executors-bibilography)
- [A Universal Async Abstraction for C++](https://cor3ntin.github.io/posts/executors/)

## Задание

1) Реализуйте пул потоков: [`static_thread_pool.cpp`](await/executors/static_thread_pool.cpp)
2) Реализуйте декоратор, поддерживающий приоритеты задач: [`priority.cpp`](await/executors/priority.cpp)  
3) Реализуйте асинхронный мьютекс: [`strand.cpp`](await/executors/strand.cpp)

## Замечания по реализации

### Thread Pool

Релизуйте простой пул потоков фиксированного размера с блокирующей очередью задач.

Маркируйте потоки пула с помощью переданного в фабричный метод имени.

### Strand

Strand реализует взаимное исключение, а значит внутри него будет спрятан мьютекс.

Поток, непосредственно исполняющий задачи strand-а, не должен при этом держать мьютекс.

Реализация не должна на бесконечное время захватывать поток пула, который в конечном счете будет исполнять критические секции.

#### Батчинг

Группируйте задачи strand-а в пакеты. Число задач, которые strand отправляет в декорируемый экзекутор не должно зависеть от интенсивности добавления задач в сам strand.

При хорошей реализации strand-а накладные расходы на синхронизацию при росте нагрузки только _снижаются_, а не возрастают, как при использовании мьютексов.

Не используйте `BlockingQueue`: 1) в strand-е не предполагается никакого блокирующего ожидания 2) интерфейс блокирующей очереди сам по себе противоречит идее батчинга.

#### Lock-Free Queue

От мьютекса, который защищает очередь задач в strand-е, можно избавиться, используя лок-фри очередь.

В общем случае использование лок-фри контейнеров требует нетривиального механизма управления памятью для решения ABA, да и сама очередь – не слишком простой в реализации контейнер. Но в случае со strand-ом все оказывается гораздо проще: будет достаточно простого лок-фри стека и умения из двух стеков собрать очередь.

С лок-фри очередью синхронизация в strand-е сведется практически к одной атомарной операции как при планировании задачи, так и при захвате целой пачки задач при непосредственном исполнении.
