# Future

Напишите аналог [`std::future`](https://en.cppreference.com/w/cpp/thread/future).

## Blocking Futures

Пара `Future<T>` + `Promise<T>` образует "канал" для возврата результата из асинхронной операции.

_Результат_ – значение типа `T` или исключение.

`Promise<T>` – конец канала для записи, предоставляет два метода: `SetValue` для передачи значения и `SetException` для передачи исключения.

`Future<T>` – конец канала для чтения, предоставляет единственный метод `Get`, который блокирует поток до тех пор, пока через `Promise` не будет отправлен результат.  

Канал – _одноразовый_: вызвать `SetValue` / `SetException` на `Promise` и `Get` на `Future` можно только один раз, в противном случае – UB.

Другая интерпретация: 

Пара `Future<T>` + `Promise<T>` образует контракт: поток-_producer_ обязуется выполнить контракт, передав потоку-_consumer_-у

## Пример

```cpp
// Пул потоков для вычислений
tp::ThreadPool pool{/*workers=*/4};

// Создаем "канал" или "контракт"
stdlike::Promise<int> p;
auto f = p.MakeFuture();

pool.Submit([p = std::move(p)]() mutable {
  std::this_thread::sleep_for(3s);  // <-- Тут можно представить тяжелое вычисление
  p.SetValue(42);  // <-- "Возвращаем" значение, "исполняем контракт"
});

int value = f.Get();  // <-- Дожидаемся значения
```

## Disclaimer

В этой задаче мы рассматриваем только наивные блокирующие фьючи, в том виде, в котором они представлены в `std`.

## Указания по реализации

Используйте [`std::variant`](https://en.cppreference.com/w/cpp/utility/variant) для представления результата (значения / исключения)

Используйте [`std::exception_ptr`](https://en.cppreference.com/w/cpp/error/exception_ptr) для того, чтобы переносить исключения между потоками.

В этой задаче вы можете создавать новые файлы в библиотеке `futures`.

Дополнительные классы, которые пользователь не должен использовать напрямую, спрячьте во вложенное пространство имен `stdlike::detail`.

### `void` vs `std::monostate`

Для `T` = `void` потребуется специализация шаблона: метод `SetValue(T)` у `Promise` нужно заменить на `Set()`, а `T Get()` у `Future` – на `void Wait()`. 

Мы проигнорируем эту сложность и в качестве альтернативы будем использовать `T` = [`std::monostate`](https://en.cppreference.com/w/cpp/utility/variant/monostate) (_unit_-тип, тип с единственным значением). 